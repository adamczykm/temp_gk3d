#version 330 core

in vec3 position_world;
in vec3 normal_camera;
in vec3 eyedir_camera;
in vec3 lightdir_camera;

out vec3 color;

uniform mat4 MV;
uniform vec3 lightpos_world;

uniform vec3 diffuse;
uniform vec3 ambient;
uniform vec3 specular;

uniform vec3 lightcol;
uniform float lightpow;

void main(){

  // Distance to the light
  float distance = length( lightpos_world - position_world );

  // Normal of the computed fragment, in camera space
  vec3 n = normalize(normal_camera);
  // Direction of the light (from the fragment to the light)
  vec3 l = normalize(lightdir_camera);
  // Cosine of the angle between the normal and the light direction,
  // clamped above 0
  //  - light is at the vertical of the triangle -> 1
  //  - light is perpendicular to the triangle -> 0
  //  - light is behind the triangle -> 0
  float cos_theta = clamp(dot(n, l), 0, 1);

  // Eye vector (towards the camera)
  vec3 E = normalize(eyedir_camera);

  // Direction in which the triangle reflects the light
  vec3 R = reflect(-l,n);

  // Cosine of the angle between the Eye vector and the Reflect vector,
  // clamped to 0
  //  - Looking into the reflection -> 1
  //  - Looking elsewhere -> < 1
  float cos_alpha = clamp(dot(E, R), 0, 1);

  color =
    // Ambient : simulates indirect lighting
    ambient +
    // Diffuse : "color" of the object
    diffuse * lightcol * lightpow * cos_theta / (distance*distance) +
    // Specular : reflective highlight, like a mirror
    specular * lightcol * lightpow * pow(cos_alpha,5) / (distance*distance);

  color = clamp(color,0,1);

}

// float3 viewVec = normalize(i.viewVec);
// float3 normal = normalize(i.norm);
// float3 lightVec = normalize(i.lightVec0);
// float3 halfVec = normalize(viewVec + lightVec);
// float3 color = surfaceColor * ambientColor;
// color += lightColor * surfaceColor * kd * saturate(dot(normal, lightVec)) +
// lightColor * ks * pow(saturate(dot(normal, halfVec)), m);
// lightVec = normalize(i.lightVec1);
// halfVec = normalize(viewVec + lightVec);
// color += lightColor * surfaceColor * kd * saturate(dot(normal, lightVec)) +
// lightColor * ks * pow(saturate(dot(normal, halfVec)), m);
// return float4(saturate(color), surfaceColor.a);
