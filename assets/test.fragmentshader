#version 330 core

in vec3 position_world;
in vec3 normal_camera;
in vec3 eyedir_camera;
in vec3 lightdir_camera;

out vec3 color;

uniform mat4 MV;
uniform vec3 lightpos_world;


void main(){
  // Light emission properties
  // You probably want to put them as uniforms
  vec3 lightcol = vec3(1,1,1);
  float lightpow = 1000.0f;

  // Material properties
  vec3 diffuse = vec3(0.9, 0.1, 0.1);
  vec3 ambient = vec3(0.1,0.1,0.1) * diffuse;
  vec3 specular = vec3(0.3,0.3,0.3);

  // Distance to the light
  float distance = length( lightpos_world - position_world );

  // Normal of the computed fragment, in camera space
  vec3 n = normalize(normal_camera);
  // Direction of the light (from the fragment to the light)
  vec3 l = normalize(lightdir_camera);
  // Cosine of the angle between the normal and the light direction,
  // clamped above 0
  //  - light is at the vertical of the triangle -> 1
  //  - light is perpendicular to the triangle -> 0
  //  - light is behind the triangle -> 0
  float cos_theta = clamp(dot(n, l), 0, 1);

  // Eye vector (towards the camera)
  vec3 E = normalize(eyedir_camera);

  // Direction in which the triangle reflects the light
  vec3 R = reflect(-l,n);

  // Cosine of the angle between the Eye vector and the Reflect vector,
  // clamped to 0
  //  - Looking into the reflection -> 1
  //  - Looking elsewhere -> < 1
  float cos_alpha = clamp(dot(E, R), 0, 1);

  color =
    // Ambient : simulates indirect lighting
    ambient +
    // Diffuse : "color" of the object
    diffuse * lightcol * lightpow * cos_theta / (distance*distance) +
    // Specular : reflective highlight, like a mirror
    specular * lightcol * lightpow * pow(cos_alpha,5) / (distance*distance);

}
